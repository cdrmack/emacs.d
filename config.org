#+TITLE: GNU Emacs Configuration
#+AUTHOR: cdrmack
#+STARTUP: overview

This is my GNU Emacs configuration file, written in org and... Emacs of course.

* General Settings

I want my Emacs to start with an empty =*scratch*= buffer.
This is why I disable the startup-message.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+end_src

I use a separate file for storing Emacs' customization information.
By default it's stored in the init file specified by the =user-init-file= variable.
However it can be changed by modyfing the =custom-file= variable.

#+begin_src emacs-lisp
  (setq custom-file
	(expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror 'nomessage)
#+end_src

Use =<escape>= globally to exit the current "mode".

#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

Flash the screen when I do something stupid. Still not sure if I like it.

#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

I am also too lazy to write =yes= or =no= in different prompts.
The following alias allows me to simply type =y= or =n= when asked.

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

If a file changes on the disk I want Emacs to detect that and refresh my buffer automatically.
Same goes when I am currently in the =dired-mode= and files' structure changes.

#+begin_src emacs-lisp
  (global-auto-revert-mode t)
  (add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

=recentf-mode= - when enabled I can check the recently operated files with =M-x recentf-open-files=.

#+begin_src emacs-lisp
  (recentf-mode t)
#+end_src

Save minibuffer history to the =savehist-file=.
I can then use =M-n= and =M-p= in the minibuffer to scroll through it.

#+begin_src emacs-lisp
  (setq history-length 25)
  (savehist-mode t)
#+end_src

By default =zap-up-to-char= removes text from the current cursor position to a given char... including the char.
I do not want that. Please leave this poor char alone!

#+begin_src emacs-lisp
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src

=saveplace= is a built-in package that allows saving the cursor position in a file.
When I reopen the same file later on, the coursor will be set in the saved position.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src

I like to know what time it is.

#+begin_src emacs-lisp
  (display-time-mode t)
#+end_src

Store autosave files in a specific directory.

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
	`((".*" ,(concat user-emacs-directory "auto-save/") t)))
#+end_src

Same for the backup files.

#+begin_src emacs-lisp
  (setq backup-by-copying t
	backup-directory-alist `(("." . (concat user-emacs-directory "backups/")))
	delete-old-versions t
	kept-new-versions 6
	kept-old-versions 2)
#+end_src

** Packages Repositories

In Emacs you can use more than one repository to download packages.
Repositories are stored in the variable called =package-archives=.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives '(("elpa" . "https://elpa.gnu.org/packages/")
			   ("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")))

  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

I use =use-package= to keep all my packages clean and sexy.
Before I will use it I need to install it though since it's not a built-in package.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
#+end_src

The =:ensure= keyword causes the package to be installed automatically if not already present in the system.
The variable below makes sure that setting is set by default for all packages.

#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

* Look

I like to have more than less space for my buffers.
This is why I disable menu-bar, tool-bar and scroll-bars.

#+begin_src emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+end_src

I also like to see line numbers always (almost) visible.

#+begin_src emacs-lisp
  (setq column-number-mode t)
  (setq line-number-mode t)

  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq-default display-line-numbers-width 3)
#+end_src

I use doom-palenight theme.

#+begin_src emacs-lisp
  (use-package doom-themes
    :init
    (load-theme 'doom-palenight t))
#+end_src

Use and format various icon fonts withing Emacs.
Run =M-x all-the-icons-install-fonts= when on a new machine.

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

Highlight the current line.

#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

In my opinion font is a really important thing. I used to look at the code and wonder:

#+begin_quote
Is it a big O or 0?
Is it l (small L) or maybe I (capital i)?
#+end_quote

Well... not anymore! I highly encourage you to take your time and find a font that suits your needs.

I'm currently testing =Fira Code=.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
		      :family "Fira Code"
		      :height 120
		      :weight 'normal
		      :width 'normal)
#+end_src

On FreeBSD it can be installed via =pkg(8)=.

#+begin_src shell
  pkg install firacode
#+end_src

Emojis... ðŸ‘€

#+begin_src emacs-lisp
  (set-fontset-font t 'unicode "Symbola" nil 'prepend)
#+end_src

Don't use dialog boxes. I prefer working with the keyboard.

#+begin_src emacs-lisp
  (setq use-dialog-box nil)
#+end_src

Fancy mode-line.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1))
#+end_src

* Navigation

Package that provides a generic completion mechanism.

#+begin_src emacs-lisp
  (use-package ivy
    :init (ivy-mode 1)
    :diminish
    :bind (:map ivy-minibuffer-map
		("TAB" . ivy-alt-done)
		("C-j" . ivy-next-line)
		("C-k" . ivy-previous-line)
		:map ivy-switch-buffer-map
		("C-k" . ivy-previous-line)
		("C-l" . ivy-done)
		("C-d" . ivy-switch-buffer-kill)
		:map ivy-reverse-i-search-map
		("C-k" . ivy-previous-line)
		("C-d" . ivy-reverse-i-search-kill)))
#+end_src

Add description and key-binding to the listed functions in =M-x=.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :init (ivy-rich-mode 1))
#+end_src

=counsel= provides a collection of ivy-enhanced versions of common commands.

#+begin_src emacs-lisp
  (use-package counsel
    :bind (("M-x" . counsel-M-x)
	   ("C-x C-f" . counsel-find-file)
	   ("C-h f" . counsel-describe-function)
	   ("C-h v" . counsel-describe-variable)
	   ("C-h l" . counsel-find-library)
	   ("C-h i" . counsel-info-lookup-symbol)
	   ("C-h u" . counsel-unicode-char)
	   :map minibuffer-local-map
	   ("C-r" . 'counsel-minibuffer-history)))
#+end_src

Displays the key bindings following my currently entered incomplete command.

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish
    :config
    (setq which-key-idle-delay 0.5))
#+end_src

Replaces built-in =other-window= by assigning each window a short, unique label.

#+begin_src emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . ace-window)))
#+end_src

* Search

ivy-enhanced alternative to isearch.

#+begin_src emacs-lisp
    (use-package swiper)
#+end_src

=avy= is a package that helps with moving point all over Emacs.
It has this cool feature to jump to the location with a single keystroke.
How many characters are needed to trigger avy is controlled by the =ace-isearch= package.

#+begin_src emacs-lisp
  (use-package avy)
#+end_src

This is a minor mode that combines =isearch=, =avy= and =swiper=.
Results are based on the length of the search query.

#+begin_src emacs-lisp
  (use-package ace-isearch
    :init
    (setq ace-isearch-jump-based-on-one-char t)
    :diminish
    :config
    (global-ace-isearch-mode 1))
#+end_src
